{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { useState, useEffect, createElement, Component } from 'react';\nimport invariant from 'invariant';\nvar INSTANCE_MAP = new Map();\nvar OBSERVER_MAP = new Map();\n/**\n * Monitor element, and trigger callback when element becomes visible\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be visible before triggering\n * @param options.root {HTMLElement} It should have a unique id or data-intersection-id in order for the Observer to reused.\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n * @param rootId {String} Unique identifier for the root element, to enable reusing the IntersectionObserver\n */\n\nfunction observe(element, callback, options, rootId) {\n  if (options === void 0) {\n    options = {};\n  } // Validate that the element is not being used in another <Observer />\n\n\n  invariant(!INSTANCE_MAP.has(element), \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\", element); // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n\n  if (!options.threshold) options.threshold = 0;\n  var _options = options,\n      root = _options.root,\n      rootMargin = _options.rootMargin,\n      threshold = _options.threshold;\n  if (!element || !callback) return;\n  var observerId = rootMargin ? threshold.toString() + \"_\" + rootMargin : threshold.toString();\n\n  if (root) {\n    observerId = rootId ? rootId + \"_\" + observerId : null;\n  }\n\n  var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : null;\n\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options);\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);\n  }\n\n  var instance = {\n    callback: callback,\n    visible: false,\n    options: options,\n    observerId: observerId,\n    observer: !observerId ? observerInstance : undefined\n  };\n  INSTANCE_MAP.set(element, instance);\n  observerInstance.observe(element);\n  return instance;\n}\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {HTMLElement}\n */\n\n\nfunction unobserve(element) {\n  if (!element) return;\n  var instance = INSTANCE_MAP.get(element);\n\n  if (instance) {\n    var observerId = instance.observerId,\n        observer = instance.observer;\n    var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : observer;\n\n    if (observerInstance) {\n      observerInstance.unobserve(element);\n    } // Check if we are still observing any elements with the same threshold.\n\n\n    var itemsLeft = false;\n\n    if (observerId) {\n      INSTANCE_MAP.forEach(function (item, key) {\n        if (item && item.observerId === observerId && key !== element) {\n          itemsLeft = true;\n        }\n      });\n    }\n\n    if (observerInstance && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observerInstance.disconnect();\n      OBSERVER_MAP.delete(observerId);\n    } // Remove reference to element\n\n\n    INSTANCE_MAP.delete(element);\n  }\n}\n\nfunction onChange(changes) {\n  changes.forEach(function (intersection) {\n    var isIntersecting = intersection.isIntersecting,\n        intersectionRatio = intersection.intersectionRatio,\n        target = intersection.target;\n    var instance = INSTANCE_MAP.get(target); // Firefox can report a negative intersectionRatio when scrolling.\n\n    if (instance && intersectionRatio >= 0) {\n      var options = instance.options;\n      var _inView = false;\n\n      if (Array.isArray(options.threshold)) {\n        // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n        _inView = options.threshold.some(function (threshold) {\n          return instance.visible ? intersectionRatio > threshold : intersectionRatio >= threshold;\n        });\n      } else if (options.threshold !== undefined) {\n        // Trigger on 0 ratio only when not visible. This is fallback for browsers without isIntersecting support\n        _inView = instance.visible ? intersectionRatio > options.threshold : intersectionRatio >= options.threshold;\n      }\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        _inView = _inView && isIntersecting;\n      }\n\n      instance.visible = _inView;\n      instance.callback(_inView, intersectionRatio);\n    }\n  });\n}\n\nfunction useInView(ref, options) {\n  if (options === void 0) {\n    options = {};\n  } // $FlowFixMe - useState is not exposed in React Flow lib yet\n\n\n  var _React$useState = useState(false),\n      isInView = _React$useState[0],\n      setInView = _React$useState[1]; // $FlowFixMe - useEffect is not exposed in React Flow lib yet\n\n\n  useEffect(function () {\n    if (ref.current) {\n      observe(ref.current, function (inView) {\n        setInView(inView);\n\n        if (inView && options.triggerOnce) {\n          // If it should only trigger once, unobserve the element after it's inView\n          unobserve(ref.current);\n        }\n      }, {\n        threshold: options.threshold,\n        root: options.root,\n        rootMargin: options.rootMargin\n      }, options.rootId);\n    }\n\n    return function () {\n      unobserve(ref.current);\n    };\n  }, [options.threshold, options.root, options.rootMargin, options.rootId]);\n  return isInView;\n}\n/**\n * Monitors scroll, and triggers the children function with updated props\n *\n <InView>\n {({inView, ref}) => (\n   <h1 ref={ref}>{`${inView}`}</h1>\n )}\n </InView>\n */\n\n\nvar InView = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(InView, _React$Component);\n\n  function InView() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      inView: false,\n      intersectionRatio: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"node\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleNode\", function (node) {\n      if (_this.node) unobserve(_this.node);\n      _this.node = node;\n\n      _this.observeNode();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleChange\", function (inView, intersectionRatio) {\n      _this.setState({\n        inView: inView,\n        intersectionRatio: intersectionRatio\n      });\n\n      if (_this.props.onChange) {\n        _this.props.onChange(inView, intersectionRatio);\n      }\n    });\n\n    return _this;\n  }\n\n  var _proto = InView.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.props.hasOwnProperty('render')) {\n        console.warn(\"react-intersection-observer: \\\"render\\\" is deprecated, and should be replaced with \\\"children\\\"\", this.node);\n      }\n\n      invariant(this.node, \"react-intersection-observer: No DOM node found. Make sure you forward \\\"ref\\\" to the root DOM element you want to observe.\");\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold) {\n      unobserve(this.node);\n      this.observeNode();\n    }\n\n    if (prevState.inView !== this.state.inView) {\n      if (this.state.inView && this.props.triggerOnce) {\n        unobserve(this.node);\n        this.node = null;\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.node) {\n      unobserve(this.node);\n      this.node = null;\n    }\n  };\n\n  _proto.observeNode = function observeNode() {\n    if (!this.node) return;\n    var _this$props = this.props,\n        threshold = _this$props.threshold,\n        root = _this$props.root,\n        rootMargin = _this$props.rootMargin,\n        rootId = _this$props.rootId;\n    observe(this.node, this.handleChange, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin\n    }, rootId);\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        render = _this$props2.render,\n        tag = _this$props2.tag,\n        triggerOnce = _this$props2.triggerOnce,\n        threshold = _this$props2.threshold,\n        root = _this$props2.root,\n        rootId = _this$props2.rootId,\n        rootMargin = _this$props2.rootMargin,\n        props = _objectWithoutPropertiesLoose(_this$props2, [\"children\", \"render\", \"tag\", \"triggerOnce\", \"threshold\", \"root\", \"rootId\", \"rootMargin\"]);\n\n    var _this$state = this.state,\n        inView = _this$state.inView,\n        intersectionRatio = _this$state.intersectionRatio;\n    var renderMethod = children || render;\n\n    if (typeof renderMethod === 'function') {\n      return renderMethod({\n        inView: inView,\n        intersectionRatio: intersectionRatio,\n        ref: this.handleNode\n      });\n    }\n\n    return createElement(tag || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  };\n\n  return InView;\n}(Component);\n\n_defineProperty(InView, \"defaultProps\", {\n  threshold: 0,\n  triggerOnce: false\n});\n\nexport default InView;\nexport { InView, useInView };","map":null,"metadata":{},"sourceType":"module"}